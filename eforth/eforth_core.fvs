const TIBB = 0x3000

const BKSPP = 8
const LF = 10
const CRR = 13

// -------------------------------------------------------------------------
// Device dependent I/O

def asm(code) alias QRX ?RX
    ifkt FKT_KEY
    PUSHD(%acc1)
    NEXT()
end

def asm(code) alias TXSTO TX!
    POPD(%acc1)
    ifkt FKT_EMIT
    NEXT()
end

// -------------------------------------------------------------------------
// kernel words

def asm(code) doLIT
    mov %acc1, [%ip++]
    PUSHD(%acc1)
    NEXT()
end

def asm(code) BYE
    ifkt FKT_TERMINATE
end

def asm(code) EXIT
    mov %ip, [--%rsp]
    NEXT()
end

def asm(code) EXECUTE
    POPD(%acc1)
    jmp %acc1
    NEXT()
end

def asm(code) next
    mov %acc1, #0x1
    mov %acc2, %acc1
    POPR(%acc1)
    sub %acc1, %acc1, %acc2
    jc :next1
    PUSHR(%acc1)
    mov %ip, [%ip]
    NEXT()
next1:
    mov %acc1, CELLSIZE
    add %ip, %ip, %acc1
    NEXT()
end

def asm(code) BRANCH
    mov %ip, [%ip]
    NEXT()
end

def asm(code) ?BRANCH
    POPD(%acc1)
    jz :nobranch
    mov %acc1, CELLSIZE
    add %ip, %ip, %acc1
    NEXT()
nobranch:
    mov %ip, [%ip]
    NEXT()
end

// -------------------------------------------------------------------------
// memory fetch & store

def asm(code) !       // w a --
    POPD(%acc1)
    POPD(%acc2)
    mov [%acc1], %acc2
    NEXT()
end

def asm(code) @       // a -- w
    POPD(%acc1)
    mov %acc1, [%acc1]
    PUSHD(%acc1)
    NEXT()
end

def asm(code) C!      // c b --
    POPD(%acc1)     // get address
    POPD(%acc2)     // get data
    mov.b [%acc1], %acc2
    NEXT()
end

def asm(code) C@      // b -- c
    POPD(%acc1)     // get address
    mov.b %acc2, [%acc1]    // fetch the character from this address
    PUSHD(%acc2)    // push the character on the data stack
    NEXT()
end

// -------------------------------------------------------------------------
// return stack

def asm(code) RP@     // -- a
    PUSHD(%rsp)
    NEXT()
end

def asm[COMPILE_ONLY](code) RP!     // a --
    POPD(%rsp)
    NEXT()
end

def asm[COMPILE_ONLY](code) R>      // -- w
    POPR(%acc1)
    PUSHD(%acc1)
    NEXT()
end

def asm(code) R@      // -- w
    POPR(%acc1)
    PUSHR(%acc1)
    PUSHD(%acc1)
    NEXT()
end

def asm[COMPILE_ONLY](code) >R      // w --
    POPD(%acc1)
    PUSHR(%acc1)
    NEXT()
end

// -------------------------------------------------------------------------
// data stack

def asm(code) SP@       // -- a
    mov %acc1, %dsp
    PUSHD(%acc1)
    NEXT()
end

def asm(code) SP!       // a --
    POPD(%acc1)
    mov %dsp, %acc1
    NEXT()
end

def asm(code) DROP      // w --
    POPD(%acc1)
    NEXT()
end

def asm(code) DUP       // w -- w w
    POPD(%acc1)
    PUSHD(%acc1)
    PUSHD(%acc1)
    NEXT()
end

def asm(code) SWAP      // w1 w2 -- w2 w1
    POPD(%acc1)
    POPD(%acc2)
    PUSHD(%acc1)
    PUSHD(%acc2)
    NEXT()
end

def asm(code) OVER    // w1 w2 -- w1 w2 w1
    POPD(%acc2)
    POPD(%acc1)
    PUSHD(%acc1)
    PUSHD(%acc2)
    PUSHD(%acc1)
    NEXT()
end

def word(colon) ?DUP    // w -- w w | 0
    DUP ?BRANCH :qdup1
    DUP
qdup1:
    EXIT
end

def word(colon) NIP     // w1 w2 -- w2
    SWAP DROP
    EXIT
end

def word(colon) ROT     // w1 w2 w3 -- w2 w3 w1
    >R SWAP R> SWAP
    EXIT
end

def word(colon) 2DROP   // w w --
    DROP DROP
    EXIT
end

def word(colon) 2DUP    // w1 w2 -- w1 w2 w1 w2
    OVER OVER
    EXIT
end

// -------------------------------------------------------------------
// Logic

def asm(code) 0<
    POPD(%acc1)
    sra %acc1, #31
    PUSHD(%acc1)
    NEXT()
end

def asm(code) OR
    POPD(%acc1)
    POPD(%acc2)
    or %acc1, %acc1, %acc2
    PUSHD(%acc1)
    NEXT()
end

def asm(code) AND
    POPD(%acc1)
    POPD(%acc2)
    and %acc1, %acc1, %acc2
    PUSHD(%acc1)
    NEXT()
end

def asm(code) XOR
    POPD(%acc1)
    POPD(%acc2)
    xor %acc1, %acc1, %acc2
    PUSHD(%acc1)
    NEXT()
end

def word(colon) NOT
    doLIT -1 XOR
    EXIT
end

// -------------------------------------------------------------------
// Arithmetic

def asm(code) UM+           // u u -- u cy or u u -- ud
    POPD(%acc1)
    POPD(%acc2)
    add %acc1, %acc1, %acc2
    jc :ump_carry
    mov %acc2, #0
    jmp :ump_push_all
ump_carry:
    mov %acc2, #1
ump_push_all:
    PUSHD(%acc1)
    PUSHD(%acc2)
    NEXT()
end

def word(colon) +           // u u -- u
    UM+ DROP
    EXIT
end

def word(colon) NEGATE      // n -- -n
    NOT doLIT 1 +
    EXIT
end

def word(colon) DNEGATE     // d -- -d
    NOT >R NOT doLIT 1 UM+ R> +
    EXIT
end

def asm(code) -             // w w -- w
    POPD(%acc2)
    POPD(%acc1)
    sub %acc1, %acc1, %acc2
    PUSHD(%acc1)
    NEXT()
end

def word(colon) ABS         // n -- +n
    DUP 0<
    ?BRANCH :abs1
    NEGATE
abs1:
    EXIT
end

// -------------------------------------------------------------------
// system variables

def word(colon) doVAR
    R>
    EXIT
end

def word(colon) UP
    doVAR :uzero
end

def word(colon) doUSER  // -- a
    R> @
    UP @ +
    EXIT
end

macro __DEFUSERVAR_CFA()
    call :doLIST
    dw :douser_cfa
end

def asm(uservar) SP0
    USER_OFFSET(:u_sp0)
end

def asm(uservar) RP0
    USER_OFFSET(:u_rp0)
end

def asm(uservar) '?KEY
    USER_OFFSET(:u_qkey)
end

def asm(uservar) 'EMIT
    USER_OFFSET(:u_temit)
end

def asm(uservar) 'EXPECT
    USER_OFFSET(:u_texpect)
end

def asm(uservar) temp
    USER_OFFSET(:u_temp)
end

def asm(uservar) SPAN
    USER_OFFSET(:u_span)
end

def asm(uservar) >IN
    USER_OFFSET(:u_toin)
end

def asm(uservar) #TIB
    USER_OFFSET(:u_htib)
end

def asm(uservar) HLD
    USER_OFFSET(:u_hld)
end

def asm(uservar) HANDLER
    USER_OFFSET(:u_handler)
end

def asm(uservar) CP
    USER_OFFSET(:u_ctop)
end

// -------------------------------------------------------------------
// Comparison

def word(colon) alias EQUAL =  // w w -- t
    XOR
    ?BRANCH :equ1
    doLIT 0 EXIT        // values are different
equ1:
    doLIT -1 EXIT       // values are equal
end

def word(colon) U<      // u u -- t
    2DUP XOR 0<
    ?BRANCH :ules1
    SWAP DROP 0< EXIT
ules1:
    - 0<
    EXIT
end

def word(colon) <       // n1 n2 -- t
    2DUP XOR 0<
    ?BRANCH :less1
    DROP 0< EXIT
less1:
    - 0< EXIT
end

def word(colon) MIN     // n n -- n
    2DUP SWAP <
    ?BRANCH :min1
    SWAP
min1:
    DROP
    EXIT
end

def word(colon) MAX     // n n -- n
    2DUP <
    ?BRANCH :max1
    SWAP
max1:
    DROP
    EXIT
end

def word(colon) WITHIN      // u ul uh -- t
    OVER - >R - R> U<
    EXIT
end

// -------------------------------------------------------------------
// Divide

def word(colon) UM/MOD  // udl udh un -- ur uq
    2DUP U<
    ?BRANCH :umm4
    NEGATE doLIT 31 >R  // 31 for the amount of bits in CELL
umm1:
    >R DUP UM+
    >R >R DUP UM+
    R> + DUP
    R> R@ SWAP >R
    UM+ R> OR
    ?BRANCH :umm2
    >R DROP doLIT 1 + R>
    BRANCH :umm3
umm2:
    DROP
umm3:
    R>
    next :umm1
    DROP SWAP EXIT
umm4:
    DROP 2DROP
    doLIT -1 DUP EXIT
end

def word(colon) M/MOD   // d n -- r q
    DUP 0< DUP >R
    ?BRANCH :mmod1
    NEGATE >R DNEGATE R>
mmod1:
    >R DUP 0<
    ?BRANCH :mmod2
    R@ +
mmod2:
    R> UM/MOD R>
    ?BRANCH :mmod3
    SWAP NEGATE SWAP
mmod3:
    EXIT
end

def word(colon) /MOD    // n n -- r q
    OVER 0< SWAP M/MOD
    EXIT
end

def word(colon) MOD     // n n -- r
    /MOD DROP
    EXIT
end

def word(colon) /       // n n -- q
    /MOD NIP
    EXIT
end


// -------------------------------------------------------------------
// Bits & Bytes

def word(colon) CELL+
    doLIT 4 +
    EXIT
end

def word(colon) BL
    doLIT 32
    EXIT
end

def word[IMMEDIATE](colon) ALIGNED // b -- a
    // TODO
    EXIT
end

// -------------------------------------------------------------------
// Memory access

def word(colon) COUNT   // b -- b +n
    DUP doLIT 1 + SWAP C@
    EXIT
end

def word(colon) HERE    // -- a
    CP @
    EXIT
end

def word(colon) TIB     // -- a
    #TIB CELL+ @
    EXIT
end

def word(colon) @EXECUTE    // a --
    @ ?DUP
    ?BRANCH :exe1
    EXECUTE
exe1:
    EXIT
end

def word(colon) CMOVE   // b1 b2 u --
    >R
    BRANCH :cmov2
cmov1:
    >R DUP C@ R@ C!
    doLIT 1 +
    R> doLIT 1 +
cmov2:
    next :cmov1
    2DROP
    EXIT
end

def word(colon) PACK$   // b u a -- a
    ALIGNED DUP >R      // strings only on cell boundary
    OVER DUP doLIT 0
    doLIT 4 UM/MOD DROP // count mod cell
    - OVER +
    doLIT 0 SWAP !      // null fill cell
    2DUP C! doLIT 1 +   // save count
    SWAP CMOVE R>       // move string
    EXIT
end

// -------------------------------------------------------------------
// Basic I/O

def word(colon) KEY
    '?KEY @EXECUTE
    EXIT
end

def word(colon) EMIT
    'EMIT @EXECUTE
    EXIT
end

def word(colon) ECHO
    EMIT
    EXIT
end

def word(colon) do$     // -- a
    // TODO: COMPILE-ONLY
    R> R@ R> COUNT + ALIGNED >R
    SWAP >R
    EXIT
end

def word(colon) alias STRQP $"| // -- a
    do$
    EXIT
end

def word(colon) TYPE    // b u --
    >R
    BRANCH :type2
type1:
    DUP C@ EMIT
    doLIT 1 +
type2:
    next :type1
    DROP
    EXIT
end

// -------------------------------------------------------------------
// Parsing

def word(colon) parse   // b u c - b u delta ; <string>
    temp ! OVER >R DUP  // c in temp, b in R -- b u u
    ?BRANCH :pars8      // jump to end if length is 0
    doLIT 1 -           // b u-1
    temp @ BL =
    ?BRANCH :pars3      // goto pars3 when c!=BL
    >R                  // b, u-1 in R as loop value
pars1:
    BL OVER C@          // b BL char@b
    - 0< NOT            //
    ?BRANCH :pars2      // is the character non-printable? 
    doLIT 1 +           // yes, skip it; b+1
    next :pars1
    R> DROP             
    doLIT 0 DUP EXIT
pars2:
    R>
pars3:
    OVER SWAP
    >R
pars4:
    temp @ OVER C@ -    // scan for delimiter
    temp @ BL =
    ?BRANCH :pars5
    0<
pars5:
    ?BRANCH :pars6
    doLIT 1 +
    next :pars4
    DUP >R
    BRANCH :pars7
pars6:
    R> DROP DUP
    doLIT 1 + >R
pars7:
    OVER -
    R> R> - EXIT
pars8:
    OVER R> - EXIT
end

// -------------------------------------------------------------------
// Forth compiler

def word(colon) TAP     // bot eot cur c -- bot eot cur
    DUP ECHO OVER C! doLIT 1 +
    EXIT
end

def word(colon) kTAP
    DUP doLIT 13 XOR
    ?BRANCH :ktap2
    doLIT 8 XOR
    ?BRANCH :ktap1
    BL TAP EXIT
ktap1:
    doLIT 8 EXIT        // TODO: This should actually perform a backspace
ktap2:
    DROP SWAP DROP DUP
    EXIT
end

def word(colon) accept  // b u -- b u
// accept characters to input buffer, return with actual count
    OVER + OVER         // b b+u b
accept1:
    2DUP                // b b+u b b+u b
    XOR
    ?BRANCH :accept4
    KEY DUP
    BL - doLIT 95 U<
    BL doLIT 127 WITHIN
    ?BRANCH :accept2
    TAP
    BRANCH :accept3
accept2:
    kTAP         // 'TAP @EXECUTE
accept3:
    BRANCH :accept1
accept4:
    DROP OVER -
    EXIT
end

def word(colon) QUERY
    TIB doLIT 80 'EXPECT @EXECUTE
    #TIB !              // Store the new number of characters in TIB
    DROP doLIT 0 >IN !  // Reset the parsing pointer
    EXIT
end

// -------------------------------
// Additional words

def asm(code) DUMP
    ifkt FKT_DUMP
    NEXT()
end

def asm(code) ILLEGAL
    illegal
    NEXT()
end

def word(colon) TESTW
loop:
    QUERY
    ILLEGAL
    EXIT
end

def asm(code) TESTC
    ifkt FKT_KEY
    ifkt FKT_KEY
    ifkt FKT_DUMP
    illegal
    NEXT()
end
